<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Add/Delete Series</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link rel="stylesheet" href="../dist/uPlot.min.css">
	</head>
	<body>
		<script src="../dist/uPlot.iife.js"></script>
		<script>
			let xs = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30];

			let data = [
				xs,
			];

			const opts = {
				width: 1920,
				height: 1200,
				title: "Area Fill",
				scales: {
					x: {
						time: false,
					},
				},
				plugins: [focusPlugin()],
				hooks: {
					addSeries: [
						(u, seriesIdx) => {
							console.log("addSeries" + (u.status == 0 ? " (init)" : ""), seriesIdx);
						}
					],
					delSeries: [
						(u, seriesIdx) => {
							console.log("delSeries", seriesIdx);
						}
					],
				},
				series: [
					{},
				],
			};

			let u = new uPlot(opts, data, document.body);

			data = [xs];

			const dataLength = 400;

			for (let i = 0; i < dataLength; i++) {
				const serie = xs.map((t, j) => (180 / dataLength * i) - Math.sin(j) * 120);
				data.push(serie);
				u.setData(data, true);

				const color = getRandomColor();

				u.addSeries({
					stroke: color,
					fill: color,
				});
			}

			function getRandomColor() {
				var letters = '0123456789ABCDEF';
				var color = '#';
				for (var i = 0; i < 6; i++) {
					color += letters[Math.floor(Math.random() * 16)];
				}
				return color;
			}

			function focusPlugin() {
				let _closestDataIndex = -1;
				let over, bound, bLeft, bTop;

				function syncBounds() {
					let bbox = over.getBoundingClientRect();
					bLeft = bbox.left;
					bTop = bbox.top;
				}

				return {
					hooks: {
						init: (u) => {
							over = u.over;

							bound = over;
							//	bound = document.body;

							over.addEventListener('mouseleave', () => {
								if (_closestDataIndex !== -1) {
									u.setHoverWidth(_closestDataIndex, 1);
								}
							});
						},
						setSize: (u) => {
							syncBounds();
						},
						setCursor: (u) => {
							const yVal = u.posToVal(u.cursor.top, 'y');

							if (!u.cursor.event || !u.cursor.event.clientX) {
								return;
							}

							const idx = u.cursor.idx;

							let closestDataIndex = 1;
							for (let i = 1; i < u.data.length; i++) {
								if (yVal || yVal === 0) {
									if (Math.abs(u.data[i][idx] - yVal) < Math.abs(u.data[closestDataIndex][idx] - yVal)) {
										closestDataIndex = i;
									}
								}
							}
							if (_closestDataIndex !== -1) {
								u.setHoverWidth(_closestDataIndex, 0);
							}
							_closestDataIndex = closestDataIndex;
							u.setHoverWidth(closestDataIndex, 3);
						}
					}
				};
			}

		</script>
	</body>
</html>
